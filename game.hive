@x64

struct rect
{
    i32 x, y, a, b;
}

class player
{
    i32 x, y;
    i32 dx, dy;
    i32 deaths;
    i32 power;
    i32 jumps;
    i32 onFoot;

    i32 pressDown;
    i32 pressLeft;
    i32 pressRight;
    i32 pressUp; # to handle jumps
    i32 pressA;
    i32 pressB;
    i32 pressC;
    
    i32 color;
    i32 bgcolor;
}


(i32 rect_size, player[] players, player me, rect[] map, i32 mapW, i32 mapH)Graphics(i32? endProc)
{
    endProc <- 0;
    
    (0)GetModuleHandle@dll(var hInstance);

    i64 hwnd;
    hwnd <- ?(
        0x200,
        new i16[]"#32770",
        new i16[]"Polling Only - Use Arrow Keys, ESC to exit",
        (0x00000000 | 0x00C00000 | 0x00080000 | 0x00040000 | 0x00020000 | 0x00010000) | 0x10000000,
        0x80000000,
        0x80000000,
        1600,
        900,
        0,
        0,
        ?hInstance,
        0
    )CreateWindowEx@dll(*);

    i32? a;
    a = new i32?();

    ()fun(a);
    
    ()fun(var x);
    
    ?(()fun(*)) + 5;

    match (hwnd)
    {
        `i64`0 {
            ?(0, new i16[]"Failed to create window", new i16[]"Error", 0x10)MessageBox@dll(*);
        }
    }

    i64 screen, allocator;
    screen <- ?(hwnd)GetDC@dll(*);
    allocator <- ?(screen)CreateCompatibleDC@dll(*);

    i32[] clientRect;
    clientRect <- new i32[](4);
    ?(hwnd, clientRect)GetClientRect@dll(*);

    i32 width, height;
    width <- clientRect[2] - clientRect[0];
    height <- clientRect[3] - clientRect[1];

    i64 buffer, oldBuffer;
    buffer <- ?(screen, width, height)CreateCompatibleBitmap@dll(*);
    oldBuffer <- ?(allocator, buffer)SelectObject@dll(*);

    i64 font, oldFont;
    font <- ?(
        16,
        0,
        0,
        0,
        400,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        new i16[]"Arial"
    )CreateFont@dll(*);

    oldFont <- ?(allocator, font)SelectObject@dll(*);
    
    i32 id;

    i64 backgroundBrush, blockBrush, SkillBgBrush, SkillFgBrush, SkillReadyPen;
    i64[] rectPen;
    i64[] rectBrush;

    rectPen <- new i64[](?players);
    rectBrush <- new i64[](?players);
    id <- 0;
    while id < `i32`?players
    {
        rectPen[id] <- ?(0, 2, players[id]?color)CreatePen@dll(*);
        rectBrush[id] <- ?(players[id]?bgcolor)CreateSolidBrush@dll(*);
        id <- id + 1;
    }
    
    backgroundBrush <- ?(0xFFFFFF)CreateSolidBrush@dll(*);
    blockBrush <- ?(0xFF8800)CreateSolidBrush@dll(*);
    SkillBgBrush <- ?(0x0000FF)CreateSolidBrush@dll(*);
    SkillFgBrush <- ?(0x00FF00)CreateSolidBrush@dll(*);
    SkillReadyPen <- ?(0, 2, 0xFF0000)CreatePen@dll(*);

    i8[] msg;
    i32 running, lastTime, frameCount, fps;

    msg <- new i8[](48);
    running <- 1;
    lastTime <- ?()GetTickCount@dll(*);
    frameCount <- fps <- 0;

    i32[] rect;
    rect <- new i32[](4);

    i16[] text;
    text <- new i16[]"Text!";

    ?(new i16[]"open \"C:\\Windows\\Media\\onestop.mid\" type sequencer alias music", 0, 0, 0)mciSendString@dll(*);
    ?(new i16[]"play music", 0, 0, 0)mciSendString@dll(*);

    while running = 1
    {
        # i32 cnt;
        # cnt <- 0;
        while ?(msg, 0, 0, 0, 1)PeekMessage@dll(*) <> 0 # && cnt < 10
        {
            match (msg[8] = `i8`0x10 && msg[9] = `i8`0x00)
            {
                -1 {
                    running <- 0;
                }
            }
            match (msg[8] = `i8`0x02 && msg[9] = `i8`0x00)
            {
                -1 {
                    running <- 0;
                }
            }
            match (msg[8] = `i8`0x12 && msg[9] = `i8`0x00)
            {
                -1 {
                    running <- 0;
                }
            }
            ?(msg)TranslateMessage@dll(*);
            ?(msg)DispatchMessage@dll(*);
            # cnt <- cnt + 1;
        }

        match (running)
        {
            1 {
                running <- ?(me, players)HandleKeyPresses(*);
            }
        }

        # draw scene

        ?(allocator, clientRect, backgroundBrush)FillRect@dll(*);

        i32 cx, cy;
        cx <- me?x - width / 2;
        cy <- me?y - height / 2;

        id <- 0;
        while id < `i32`?map
        {
            rect[0] <- map[id].x - cx;
            rect[1] <- map[id].y - cy;
            rect[2] <- map[id].a - cx;
            rect[3] <- map[id].b - cy;
            ?(allocator, rect, blockBrush)FillRect@dll(*);
            id <- id + 1;
        }
        
        i64 oldPen, oldBrush;
        oldPen <- ?(allocator, rectPen[0])SelectObject@dll(*);
        oldBrush <- ?(allocator, ?(5)GetStockObject@dll(*))SelectObject@dll(*);
        
        id <- 0;
        while id < `i32`?players
        {
            
            rect[0] <- players[id]?x - rect_size/2 - cx;
            rect[1] <- players[id]?y + rect_size/2 - cy - (rect_size * players[id]?power / 1000);
            rect[2] <- players[id]?x + rect_size/2 - cx;
            rect[3] <- players[id]?y + rect_size/2 - cy;
            
            ?(allocator, rect, rectBrush[id])FillRect@dll(*);
            
            rect[1] <- players[id]?y - rect_size/2 - cy;
            
            ?(allocator, rectPen[id])SelectObject@dll(*);

            ?(allocator, rect[0], rect[1], rect[2], rect[3])Rectangle@dll(*);
            
            id <- id + 1;
        }

        # draw UI rectangles
        # Push
        rect[0] <- 0;
        rect[1] <- 0;
        rect[2] <- 60;
        rect[3] <- 60;
        ?(allocator, rect, SkillBgBrush)FillRect@dll(*);
        rect[1] <- 60 - 60 * me?power / 100;
        ?(allocator, rect, SkillFgBrush)FillRect@dll(*);
        match me?power >= 100
        {
            -1 {
                ?(allocator, SkillReadyPen)SelectObject@dll(*);
                ?(allocator, 0, 0, 60, 60)Rectangle@dll(*);
            }
        }
        # Jump
        rect[0] <- 60;
        rect[1] <- 0;
        rect[2] <- 120;
        rect[3] <- 60;
        ?(allocator, rect, SkillBgBrush)FillRect@dll(*);
        rect[1] <- 60 - 60 * me?power / 175;
        ?(allocator, rect, SkillFgBrush)FillRect@dll(*);
        match me?power >= 175
        {
            -1 {
                ?(allocator, SkillReadyPen)SelectObject@dll(*);
                ?(allocator, 60, 0, 120, 60)Rectangle@dll(*);
            }
        }
        # Swap
        rect[0] <- 120;
        rect[1] <- 0;
        rect[2] <- 180;
        rect[3] <- 60;
        ?(allocator, rect, SkillBgBrush)FillRect@dll(*);
        rect[1] <- 60 - 60 * me?power / 300;
        ?(allocator, rect, SkillFgBrush)FillRect@dll(*);
        match me?power >= 300
        {
            -1 {
                ?(allocator, SkillReadyPen)SelectObject@dll(*);
                ?(allocator, 120, 0, 180, 60)Rectangle@dll(*);
            }
        }

        ?(allocator, oldBrush)SelectObject@dll(*);
        ?(allocator, oldPen)SelectObject@dll(*);


        ?(allocator, 1)SetBkMode@dll(*);
        ?(allocator, 0x000000)SetTextColor@dll(*);

        ?(allocator, 10, 10, text, ?text)TextOut@dll(*);

        i32 currentTime;

        frameCount <- frameCount + 1;
        currentTime <- ?()GetTickCount@dll(*);

        match currentTime - lastTime >= 1000
        {
            -1 {
                fps <- frameCount * 1000 / (currentTime - lastTime);
                frameCount <- 0;
                lastTime <- currentTime;
            }
        }


        ?(screen, 0, 0, width, height, allocator, 0, 0, 0xCC0020)BitBlt@dll(*);

        sleep 16;
    }

    ?(new i16[]"stop music", 0, 0, 0)mciSendString@dll(*);
    ?(new i16[]"close music", 0, 0, 0)mciSendString@dll(*);

    # TODO: update this part
    # SelectObject(allocator, oldFont);
    # SelectObject(allocator, oldBuffer);
    # DeleteObject(font);
    # DeleteObject(buffer);
    # DeleteObject(backgroundBrush);
    # DeleteObject(rectBrush);
    # DeleteObject(rectPen);
    # DeleteDC(allocator);
    # ReleaseDC(hwnd, screen);

    # DestroyWindow(hwnd);

    endProc <- 1;
}


[export:yes]
[entry:yes]
(i64[] args)main(i32? resultCode)
{
    i32 rect_size;
    rect_size <- 50;

    player[] players;
    players <- new player[](3);

    players[0] <- new player();
    players[0]?deaths <- 0;
    players[0]?color <- 0x550000;
    players[0]?bgcolor <- 0xFF0000;
    players[1] <- new player();
    players[1]?deaths <- 0;
    players[1]?color <- 0x005500;
    players[1]?bgcolor <- 0x00FF00;
    players[2] <- new player();
    players[2]?deaths <- 0;
    players[2]?color <- 0x000055;
    players[2]?bgcolor <- 0x0000FF;

    i32 i;
    i32 mapW, mapH;
    rect[] map;

    map <- ?()CreateMap(*, var PmapW, var PmapH);
    mapW <- ?PmapW;
    mapH <- ?PmapH;
    
    i <- 0;
    while i < `i32`?players
    {
        players[i]?jumps <- 0;
        players[i]?onFoot <- 0;
        players[i]?pressA <- 0;
        players[i]?x <- 179 % (i + 1) + i * i;
        players[i]?y <- i;
        ?(players[i], map, rect_size)SpawnPlayer(*);
        i <- i + 1;
    }

    (rect_size, players, players[0], map, mapW, mapH)Graphics[on:local](var endProc);
    (rect_size, players, players[1], map, mapW, mapH)Graphics[on:remote](var endProc);

    while ?endProc = 0
    {
        i <- 0;
        while i < `i32`?players
        {
            ?(map, players[i], mapW, mapH, rect_size)ApplyPhysicsToPlayer[on:local](*);
            i <- i + 1;
        }
        sleep 16;
    }
    
    resultCode <- 0;
}

(player me, player[] players)HandleKeyPresses(i32? running)
{   
    i32 runningTemp;
    runningTemp <- 1;
    match ?(0x1B)GetAsyncKeyState@dll(*) < `i16`0
    {
        -1 {
            runningTemp <- 0;
        }
    }

    me?pressDown <- 0;
    me?pressRight <- 0;
    me?pressLeft <- 0;
    match ?(0x25)GetAsyncKeyState@dll(*) < `i16`0
    {
        -1 {
            me?pressLeft <- 1;
            match me?onFoot = 1
            {
                -1 {
                    me?dx <- -15;
                } 0 {
                    match me?dx > 0 {-1{
                        me?dx <- me?dx - 3;
                    }}
                    match me?dx > -15 {-1{
                        me?dx <- me?dx - 1;
                    }}
                }
            }
        }
    }

    match ?(0x27)GetAsyncKeyState@dll(*) < `i16`0
    {
        -1 {
            me?pressRight <- 1;
            match me?onFoot = 1
            {
                -1 {
                    me?dx <- +15;
                } 0 {
                    match me?dx < 0 {-1{
                        me?dx <- me?dx + 3;
                    }}
                    match me?dx < 15 {-1{
                        me?dx <- me?dx + 1;
                    }}
                }
            }
        }
    }

    match ?(0x26)GetAsyncKeyState@dll(*) < `i16`0
    {
        -1 {
            match me?jumps > 0 && me?pressUp = 0
            {
                -1 {
                    me?dy <- -20;
                    me?jumps <- me?jumps - 1;
                }
            }
            me?pressUp <- 1;
        }
        0 {
            me?pressUp <- 0;
        }
    }

    match ?(0x28)GetAsyncKeyState@dll(*) < `i16`0
    {
        -1 {
            me?pressDown <- 1;
            me?dy <- +15;
        }
    }


    match ?(0x41)GetAsyncKeyState@dll(*) < `i16`0
    {
        -1 {
            match me?pressA = 1
            {
                0 {
                    me?pressA <- 1;
                    ?(me, players)pushPlayers(*);
                }
            }
        } 0 {
            me?pressA <- 0;
        }
    }


    match ?(0x53)GetAsyncKeyState@dll(*) < `i16`0
    {
        -1 {
            match me?pressB = 1
            {
                0 {
                    me?pressB <- 1;
                    ?(me)RocketJump(*);
                }
            }
        } 0 {
            me?pressB <- 0;
        }
    }


    match ?(0x44)GetAsyncKeyState@dll(*) < `i16`0
    {
        -1 {
            match me?pressC = 1
            {
                0 {
                    me?pressC <- 1;
                    ?(me, players)swapPlayer(*);
                }
            }
        } 0 {
            me?pressC <- 0;
        }
    }

    running <- runningTemp;
}

(i32 n)isqrt(i32? res)
{
    i32 x, y;
    x <- n;
    y <- (x + 1) / 2;
    while y < x
    {
        x <- y;
        y <- (x + n / x) / 2;
    }
    res <- x;
}

(player me)RocketJump(i32? task)
{
    match me?power >= 175 {-1{
        me?power <- me?power - 175;
        me?dx <- (30 * me?pressRight) - (30 * me?pressLeft);
        me?dy <- (30 * me?pressDown)  - (30 * me?pressUp);
    }}
    task <- 1;
}

(player me, player[] players)pushPlayers(i32? task)
{
    match me?power >= 100 {-1{
        me?power <- me?power - 100;
        i32 id;
        id <- 0;
        while id < `i32`?players
        {
            match players[id] = me
            {
                0 {
                    i32 ddx, ddy;
                    i32 length;
                    ddx <- players[id]?x - me?x;
                    ddy <- players[id]?y - me?y - 60; # constant little push UP
                    length <- ?(ddx * ddx + ddy * ddy)isqrt(*);
                    match length = 0 {0{
                        ddx <- ddx * 30 / length * (700 - length) / 700;
                        ddy <- ddy * 30 / length * (700 - length) / 700;
                        players[id]?dx <- players[id]?dx + ddx;
                        players[id]?dy <- players[id]?dy + ddy;
                    }}
                }
            }
            id <- id + 1;
        }
    }}
    task <- 1;
}

(player me, player[] players)swapPlayer(i32? task)
{
    match me?power >= 300 {-1{
        # find nearest enemy
        player tg; # target
        i32 best;
        i32 id;
        id <- 0;
        best <- -1;
        while id < `i32`?players
        {
            i32 ddx, ddy;
            ddx <- players[id]?x - me?x;
            ddy <- players[id]?y - me?y;
            i32 length;
            length <- ddx * ddx + ddy * ddy;
            match players[id] <> me && (length < best || best = -1)
            {
                -1 {
                    best <- length;
                    tg <- players[id];
                }
            }
            id <- id + 1;
        }
        match best <> -1 && length < 1300*1300
        {
            -1 {
                me?power <- me?power - 300;
                i32 tx, ty;
                tx <- me?x;
                ty <- me?y;
                me?x <- tg?x;
                me?y <- tg?y;
                tg?x <- tx;
                tg?y <- ty;
                me?dx <- 0;
                me?dy <- 0;
                tg?dx <- 0;
                tg?dy <- 0;
            }
        }
    }}
    task <- 1;
}

(rect[] map, player me, i32 width, i32 height, i32 rect_size)ApplyPhysicsToPlayer(i32? task)
{
    me?x <- me?x + me?dx;
    me?y <- me?y + me?dy;
    me?power <- me?power + 2;
    match me?power > 1000 {-1{
        me?power <- 1000;
    }}

    match me?x < -width {-1{
        ?(me, map, rect_size)SpawnPlayer(*);
    }}
    match me?x > width {-1{
        ?(me, map, rect_size)SpawnPlayer(*);
    }}
    match me?y < -height {-1{
        ?(me, map, rect_size)SpawnPlayer(*);
    }}
    match me?y > height {-1{
        ?(me, map, rect_size)SpawnPlayer(*);
    }}

    i32 id, px, py, dx, dy;
    id <- 0;
    px <- me?x;
    py <- me?y;
    dx <- me?dx;
    dy <- me?dy;
    me?onFoot <- 0;
    while id < `i32`?map
    {
        # 1. did we collide at all?
        i32 x, y, a, b;
        x <- map[id].x - rect_size / 2;
        y <- map[id].y - rect_size / 2;
        a <- map[id].a + rect_size / 2;
        b <- map[id].b + rect_size / 2;
        match x < px && px < a && y < py && py < b
        {-1{
            # check collision side:
            # top
            match ?(a-px,y-py,-dx,-dy)crs(*) < 0 && ?(x-px,y-py,-dx,-dy)crs(*) >= 0
            {-1{
                me?y <- y;
                me?dy <- 0;
                me?jumps <- 2;
                me?onFoot <- 1;
            }0{
            # left
            match ?(x-px,y-py,-dx,-dy)crs(*) < 0 && ?(x-px,b-py,-dx,-dy)crs(*) >= 0
            {-1{
                me?x <- x;
                me?dx <- 0;
            }0{
            # right
            match ?(a-px,b-py,-dx,-dy)crs(*) < 0 && ?(a-px,y-py,-dx,-dy)crs(*) >= 0
            {-1{
                me?x <- a;
                me?dx <- 0;
            }0{
            # bottom
            match ?(x-px,b-py,-dx,-dy)crs(*) < 0 && ?(a-px,b-py,-dx,-dy)crs(*) >= 0
            {-1{
                me?y <- b;
                me?dy <- 0;
            }}
            }}
            }}
            }}
        }}
        id <- id + 1;
    }

    # update speed
    me?dy <- me?dy + 1;

    match me?pressLeft = 0 && me?pressRight = 0 && me?onFoot = 1 {-1{
        me?dx <- me?dx * 3 / 4;
    }}

    task <- 1;
}


(i32 x, i32 y, i32 a, i32 b)dot(i32? res)
{
    res <- x * a + y * b;
}

(i32 x, i32 y, i32 a, i32 b)crs(i32? res)
{
    res <- x * b - y * a;
}


()CreateMap(rect[]? resMap, i32? w, i32? h)
{
    rect[] map;
    map <- new rect[](7);

    map[0].x <- 300;
    map[0].y <- 500;
    map[0].a <- 350;
    map[0].b <- 550;

    map[1].x <- 100;
    map[1].y <- 200;
    map[1].a <- 150;
    map[1].b <- 250;

    map[2].x <- 200;
    map[2].y <- 200;
    map[2].a <- 250;
    map[2].b <- 250;

    map[3].x <- 400;
    map[3].y <- 500;
    map[3].a <- 450;
    map[3].b <- 650;

    map[4].x <- 300;
    map[4].y <- 100;
    map[4].a <- 550;
    map[4].b <- 150;

    map[5].x <- 0;
    map[5].y <- 300;
    map[5].a <- 200;
    map[5].b <- 350;

    map[6].x <- 500;
    map[6].y <- 500;
    map[6].a <- 600;
    map[6].b <- 650;

    resMap <- map;
    w <- 3000;
    h <- 3000;
}

(player p, rect[] map, i32 rect_size)SpawnPlayer(i32? task)
{
    i32 id;
    id <- (p?x + 3 * p?y) % `i32`?map; # random seed
    p?x <- (map[id].x + map[id].a) / 2;
    p?y <- map[id].y - rect_size;
    p?dx <- 0;
    p?dy <- 0;

    p?power <- 500;
    p?deaths <- p?deaths + 1;
    
    p?pressUp <- p?pressDown <- p?pressLeft <- p?pressRight <- p?pressA <- p?pressB <- p?pressC <- 0;
    p?jumps <- 2;
    
    task <- 0;
}

[on:local]
[dllimport:Kernel32.dll]
[dllimport.entry:GetLastError]
()GetLastError(i32? error);

[on:local]
[dllimport:Kernel32.dll]
[dllimport.entry:GetModuleHandleW]
(i16[] moduleName)GetModuleHandle(i64? hInstance);

[on:local]
[dllimport:Kernel32.dll]
[dllimport.entry:GetTickCount]
()GetTickCount(i32? miliseconds);

[on:local]
[dllimport:User32.dll]
[dllimport.entry:GetDC]
(i64 window)GetDC(i64? handle);

[on:local]
[dllimport:User32.dll]
[dllimport.entry:GetAsyncKeyState]
(i32 key)GetAsyncKeyState(i16? result);

[on:local]
[dllimport:User32.dll]
[dllimport.out:lpMsg]
[dllimport.entry:PeekMessageW]
(
    i8[]  lpMsg,
    i64   hWnd,
    i32   wMsgFilterMin,
    i32   wMsgFilterMax,
    i32   wRemoveMsg
)PeekMessage(i32? handle);

[on:local]
[dllimport:User32.dll]
[dllimport.out:lpMsg]
[dllimport.entry:TranslateMessage]
(i8[] lpMsg)TranslateMessage(i32? resultCode);

[on:local]
[dllimport:User32.dll]
[dllimport.entry:FillRect]
(i64 allocator, i32[] rect, i64 brush)FillRect(i32? resultCode);

[on:local]
[dllimport:User32.dll]
[dllimport.entry:DispatchMessageW]
(i8[] lpMsg)DispatchMessage(i32? resultCode);

[on:local]
[dllimport:Gdi32.dll]
[dllimport.entry:CreateCompatibleDC]
(i64 screen)CreateCompatibleDC(i64? handle);

[on:local]
[dllimport:Gdi32.dll]
[dllimport.entry:CreateSolidBrush]
(i32 color)CreateSolidBrush(i64? handle);

[on:local]
[dllimport:Gdi32.dll]
[dllimport.entry:GetStockObject]
(i32 stock)GetStockObject(i64? handle);

[on:local]
[dllimport:Gdi32.dll]
[dllimport.entry:SetBkMode]
(i64 allocator, i32 mode)SetBkMode(i32? prevMode);

[on:local]
[dllimport:Gdi32.dll]
[dllimport.entry:SetTextColor]
(i64 allocator, i32 color)SetTextColor(i32? prevColor);

[on:local]
[dllimport:Gdi32.dll]
[dllimport.entry:TextOutW]
(i64 allocator, i32 x, i32 y, i16[] text, i32 length)TextOut(i32? prevColor);

[on:local]
[dllimport:Gdi32.dll]
[dllimport.entry:BitBlt]
(i64 allocator, i32 x, i32 y, i32 cx, i32 cy, i64 src, i32 x1, i32 y1, i32 rop)BitBlt(i32? prevColor);

[on:local]
[dllimport:Gdi32.dll]
[dllimport.entry:Rectangle]
(i64 allocator, i32 left, i32 top, i32 right, i32 bottom)Rectangle(i64? handle);

[on:local]
[dllimport:Gdi32.dll]
[dllimport.entry:CreatePen]
(i32 style, i32 width, i32 color)CreatePen(i64? handle);

[on:local]
[dllimport:Gdi32.dll]
[dllimport.entry:CreateCompatibleBitmap]
(i64 allocator, i32 x, i32 y)CreateCompatibleBitmap(i64? handle);

[on:local]
[dllimport:Gdi32.dll]
[dllimport.entry:SelectObject]
(i64 allocator, i64 object)SelectObject(i64? oldObject);

[on:local]
[dllimport:Gdi32.dll]
[dllimport.entry:CreateFontW]
(
    i32    cHeight,
    i32    cWidth,
    i32    cEscapement,
    i32    cOrientation,
    i32    cWeight,
    i32    bItalic,
    i32    bUnderline,
    i32    bStrikeOut,
    i32    iCharSet,
    i32    iOutPrecision,
    i32    iClipPrecision,
    i32    iQuality,
    i32    iPitchAndFamily,
    i16[]  pszFaceName
)CreateFont(i64? handle);

[on:local]
[dllimport:User32.dll]
[dllimport.out:rect]
[dllimport.entry:GetClientRect]
(i64 window, i32[] rect)GetClientRect(i32? resultCode);


[on:local]
[dllimport:User32.dll]
[dllimport.entry:CreateWindowExW]
(
    i32     dwExStyle,
    i16[]   lpClassName,
    i16[]   lpWindowName,
    i32     dwStyle,
    i32     X,
    i32     Y,
    i32     nWidth,
    i32     nHeight,
    i64     hWndParent,
    i64     hMenu,
    i64     hInstance,
    i64     lpParam,
)CreateWindowEx(i64? hwnd);


[on:local]
[dllimport:User32.dll]
[dllimport.entry:MessageBoxW]
(i64 hwnd, i16[] text, i16[] caption, u32 type)MessageBox(i32? result);

[affinity:0]
[on:local]
[dllimport:Winmm.dll]
[dllimport.entry:mciSendStringW]
(i16[] text, i16[] res, i32 res_size, i64 callback_hwnd)mciSendString(i32? result);
