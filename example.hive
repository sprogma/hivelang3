#
#           state:
# x, y - position of player
# dx, dy - speed of player
#

struct rect
{
    i32 x, y, a, b;
}


class player
{
    i32 x, y;
    i32 dx, dy;
    i32 lives;
    i32 power;
    i32 jumps;
    i32 onFoot;

    i32 pressAnyMove;
    i32 pressUp; # to handle jumps
    i32 pressA;
    i32 pressB;
    i32 pressC;
    
    i32 color;
    i32 bgcolor;
}


[export:yes]
(i64[] args)main(i32? resultCode)
{
    (0)GetModuleHandle(hInstance);

    i32 rect_size;
    rect_size <- 50;

    i64 hwnd;

    hwnd <- ?(
        0x200,
        new i16[]"#32770",
        new i16[]"Polling Only - Use Arrow Keys, ESC to exit",
        (0x00000000 | 0x00C00000 | 0x00080000 | 0x00040000 | 0x00020000 | 0x00010000) | 0x10000000,
        0x80000000,
        0x80000000,
        1600,
        900,
        0,
        0,
        ?hInstance,
        0
    )CreateWindowEx(*);
    resultCode <- ?()GetLastError(*);

    match (hwnd)
    {
        `i64`0 {
            ?(0, new i16[]"Failed to create window", new i16[]"Error", 0x10)MessageBox(*);
        }
    }

    player[] players;
    players <- new player[](3);

    player me;
    me <- new player();

    me?color <- 0x550000;
    me?bgcolor <- 0xFF0000;

    players[0] <- me;
    players[1] <- new player();
    players[1]?color <- 0x005500;
    players[1]?bgcolor <- 0x00FF00;
    players[2] <- new player();
    players[2]?color <- 0x000055;
    players[2]?bgcolor <- 0x0000FF;

    i64 screen, allocator;
    screen <- ?(hwnd)GetDC(*);
    allocator <- ?(screen)CreateCompatibleDC(*);

    i32[] clientRect;
    clientRect <- new i32[](4);
    ?(hwnd, clientRect)GetClientRect(*);

    i32 width, height;
    width <- clientRect[2] - clientRect[0];
    height <- clientRect[3] - clientRect[1];

    i64 buffer, oldBuffer;
    buffer <- ?(screen, width, height)CreateCompatibleBitmap(*);
    oldBuffer <- ?(allocator, buffer)SelectObject(*);

    i64 font, oldFont;
    font <- ?(
        16,
        0,
        0,
        0,
        400,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        new i16[]"Arial"
    )CreateFont(*);

    oldFont <- ?(allocator, font)SelectObject(*);
    
    i32 id;

    i64 backgroundBrush, blockBrush;
    i64[] rectPen;
    i64[] rectBrush;

    rectPen <- new i64[](?players);
    rectBrush <- new i64[](?players);
    id <- 0;
    while id < `i32`?players
    {
        rectPen[id] <- ?(0, 2, players[id]?color)CreatePen(*);
        rectBrush[id] <- ?(players[id]?bgcolor)CreateSolidBrush(*);
        id <- id + 1;
    }
    
    backgroundBrush <- ?(0xFFFFFF)CreateSolidBrush(*);
    blockBrush <- ?(0xFF8800)CreateSolidBrush(*);

    i8[] msg;
    i32 running, lastTime, frameCount, fps;

    msg <- new i8[](48);
    running <- 1;
    lastTime <- ?()GetTickCount(*);
    frameCount <- fps <- 0;

    i32[] rect;
    rect <- new i32[](4);

    i16[] text;
    text <- new i16[]"Text!";

    i32 mapW, mapH;
    rect[] map;
    rect[] particles;
    i32 particles_len;

    map <- ?()CreateMap(*, PmapW, PmapH);
    mapW <- ?PmapW;
    mapH <- ?PmapH;
    
    particles <- new rect[](512);
    particles_len <- 0;

    me?jumps <- 0;
    me?onFoot <- 0;
    me?pressA <- 0;

    id <- 0;
    while id < `i32`?players
    {
        players[id]?x <- width % (id + 1);
        players[id]?y <- id;
        ?(players[id], map, rect_size)SpawnPlayer(*);
        id <- id + 1;
    }

    # ?(new i16[]"open \"C:\\Windows\\Media\\onestop.mid\" type sequencer alias music", 0, 0, 0)mciSendString(*);
    # ?(new i16[]"play music", 0, 0, 0)mciSendString(*);

    while running = 1
    {
        while ?(msg, 0, 0, 0, 1)PeekMessage(*) <> 0
        {
            match (msg[8] = `i8`0x10 && msg[9] = `i8`0x00)
            {
                -1 {
                    running <- 0;
                }
            }
            match (msg[8] = `i8`0x02 && msg[9] = `i8`0x00)
            {
                -1 {
                    running <- 0;
                }
            }
            match (msg[8] = `i8`0x12 && msg[9] = `i8`0x00)
            {
                -1 {
                    running <- 0;
                }
            }
            ?(msg)TranslateMessage(*);
            ?(msg)DispatchMessage(*);
        }

        match ?(0x1B)GetAsyncKeyState(*) < `i16`0
        {
            -1 {
                running <- 0;
            }
        }

        me?pressAnyMove <- 0;
        match ?(0x25)GetAsyncKeyState(*) < `i16`0
        {
            -1 {
                me?pressAnyMove <- 1;
                match me?onFoot = 1
                {
                    -1 {
                        me?dx <- -15;
                    } 0 {
                        match me?dx > 0 {-1{
                            me?dx <- me?dx - 4;
                        }0{
                            me?dx <- me?dx - 1;
                        }}
                        match me?dx < -15 {-1{
                            me?dx <- -15;
                        }}
                    }
                }
            }
        }

        match ?(0x27)GetAsyncKeyState(*) < `i16`0
        {
            -1 {
                me?pressAnyMove <- 1;
                match me?onFoot = 1
                {
                    -1 {
                        me?dx <- +15;
                    } 0 {
                        match me?dx < 0 {-1{
                            me?dx <- me?dx + 4;
                        }0{
                            me?dx <- me?dx + 1;
                        }}
                        match me?dx > 15 {-1{
                            me?dx <- 15;
                        }}
                    }
                }
            }
        }

        match ?(0x26)GetAsyncKeyState(*) < `i16`0
        {
            -1 {
                match me?jumps > 0 && me?pressUp = 0
                {
                    -1 {
                        me?dy <- -20;
                        me?jumps <- me?jumps - 1;
                        me?pressUp <- -1;
                    }
                }
            }
            0 {
                me?pressUp <- 0;
            }
        }

        match ?(0x28)GetAsyncKeyState(*) < `i16`0
        {
            -1 {
                me?dy <- +15;
            }
        }

    
        match ?(0x20)GetAsyncKeyState(*) < `i16`0
        {
            -1 {
                match me?pressA = 1
                {
                    0 {
                        me?pressA <- 1;
                        # push all players
                        ?(me, players)pushPlayers(*);
                    }
                }
            } 0 {
                me?pressA <- 0;
            }
        }


        id <- 0;
        while id < `i32`?players
        {
            ?(map, players[id], mapW, mapH, rect_size)ApplyPhysicsToPlayer(*);
            id <- id + 1;
        }

        # draw scene

        ?(allocator, clientRect, backgroundBrush)FillRect(*);

        i32 cx, cy;
        cx <- me?x - width / 2;
        cy <- me?y - height / 2;

        id <- 0;
        while id < `i32`?map
        {
            rect[0] <- map[id].x - cx;
            rect[1] <- map[id].y - cy;
            rect[2] <- map[id].a - cx;
            rect[3] <- map[id].b - cy;
            ?(allocator, rect, blockBrush)FillRect(*);
            id <- id + 1;
        }
        
        i64 oldPen, oldBrush;
        oldPen <- ?(allocator, rectPen[0])SelectObject(*);
        oldBrush <- ?(allocator, ?(5)GetStockObject(*))SelectObject(*);
        
        id <- 0;
        while id < `i32`?players
        {
            
            rect[0] <- players[id]?x - rect_size/2 - cx;
            rect[1] <- players[id]?y + rect_size/2 - cy - (rect_size * players[id]?power / 1000);
            rect[2] <- players[id]?x + rect_size/2 - cx;
            rect[3] <- players[id]?y + rect_size/2 - cy;
            
            ?(allocator, rect, rectBrush[id])FillRect(*);
            
            rect[1] <- players[id]?y - rect_size/2 - cy;
            
            ?(allocator, rectPen[id])SelectObject(*);

            ?(allocator, rect[0], rect[1], rect[2], rect[3])Rectangle(*);
            
            id <- id + 1;
        }

        ?(allocator, oldBrush)SelectObject(*);
        ?(allocator, oldPen)SelectObject(*);





        ?(allocator, 1)SetBkMode(*);
        ?(allocator, 0x000000)SetTextColor(*);

        ?(allocator, 10, 10, text, ?text)TextOut(*);

        i32 currentTime;

        frameCount <- frameCount + 1;
        currentTime <- ?()GetTickCount(*);

        match currentTime - lastTime >= 1000
        {
            -1 {
                fps <- frameCount * 1000 / (currentTime - lastTime);
                frameCount <- 0;
                lastTime <- currentTime;
            }
        }


        ?(screen, 0, 0, width, height, allocator, 0, 0, 0xCC0020)BitBlt(*);

        ?(16, 1)SleepEx(*);
    }

    # ?(new i16[]"stop music", 0, 0, 0)mciSendString(*);
    # ?(new i16[]"close music", 0, 0, 0)mciSendString(*);

    # TODO: update this part
    # SelectObject(allocator, oldFont);
    # SelectObject(allocator, oldBuffer);
    # DeleteObject(font);
    # DeleteObject(buffer);
    # DeleteObject(backgroundBrush);
    # DeleteObject(rectBrush);
    # DeleteObject(rectPen);
    # DeleteDC(allocator);
    # ReleaseDC(hwnd, screen);

    # DestroyWindow(hwnd);

    resultCode <- 0;
}

(i32 n)isqrt(i32? res)
{
    i32 x, y;
    x <- n;
    y <- (x + 1) / 2;
    while y < x
    {
        x <- y;
        y <- (x + n / x) / 2;
    }
    res <- x;
}

(player me, player[] players)pushPlayers(i32? task)
{
    match me?power >= 100 {-1{
        me?power <- me?power - 100;
        i32 id;
        id <- 0;
        while id < `i32`?players
        {
            match players[id] = me
            {
                0 {
                    i32 ddx, ddy;
                    i32 length;
                    ddx <- players[id]?x - me?x;
                    ddy <- players[id]?y - me?y - 60; # constant little push UP
                    length <- ?(ddx * ddx + ddy * ddy)isqrt(*);
                    match length = 0 {0{
                        ddx <- ddx * 20 / length * (700 - length) / 700;
                        ddy <- ddy * 20 / length * (700 - length) / 700;
                        players[id]?dx <- players[id]?dx + ddx;
                        players[id]?dy <- players[id]?dy + ddy;
                    }}
                }
            }
            id <- id + 1;
        }
    }}
    task <- 1;
}

(rect[] map, player me, i32 width, i32 height, i32 rect_size)ApplyPhysicsToPlayer(i32? task)
{
    me?x <- me?x + me?dx;
    me?y <- me?y + me?dy;
    me?power <- me?power + 3;
    match me?power > 1000 {-1{
        me?power <- 1000;
    }}

    match me?x < rect_size/2 {-1{
        ?(me, map, rect_size)SpawnPlayer(*);
    }}
    match me?x > width - rect_size/2 {-1{
        ?(me, map, rect_size)SpawnPlayer(*);
    }}
    match me?y < rect_size/2 {-1{
        ?(me, map, rect_size)SpawnPlayer(*);
    }}
    match me?y > height - rect_size/2 {-1{
        ?(me, map, rect_size)SpawnPlayer(*);
    }}

    i32 id, px, py, dx, dy;
    id <- 0;
    px <- me?x;
    py <- me?y;
    dx <- me?dx;
    dy <- me?dy;
    me?onFoot <- 0;
    while id < `i32`?map
    {
        # 1. did we collide at all?
        i32 x, y, a, b;
        x <- map[id].x - rect_size / 2;
        y <- map[id].y - rect_size / 2;
        a <- map[id].a + rect_size / 2;
        b <- map[id].b + rect_size / 2;
        match x < px && px < a && y < py && py < b
        {-1{
            # check collision side:
            # top
            match ?(a-px,y-py,-dx,-dy)crs(*) < 0 && ?(x-px,y-py,-dx,-dy)crs(*) >= 0
            {-1{
                me?y <- y;
                me?dy <- 0;
                me?jumps <- 2;
                me?onFoot <- 1;
            }0{
            # left
            match ?(x-px,y-py,-dx,-dy)crs(*) < 0 && ?(x-px,b-py,-dx,-dy)crs(*) >= 0
            {-1{
                me?x <- x;
                me?dx <- 0;
            }0{
            # right
            match ?(a-px,b-py,-dx,-dy)crs(*) < 0 && ?(a-px,y-py,-dx,-dy)crs(*) >= 0
            {-1{
                me?x <- a;
                me?dx <- 0;
            }0{
            # bottom
            match ?(x-px,b-py,-dx,-dy)crs(*) < 0 && ?(a-px,b-py,-dx,-dy)crs(*) >= 0
            {-1{
                me?y <- b;
                me?dy <- 0;
            }}
            }}
            }}
            }}
        }}
        id <- id + 1;
    }

    # update speed
    me?dy <- me?dy + 1;

    match me?pressAnyMove = 0 && me?onFoot = 1 {-1{
        me?dx <- me?dx * 3 / 4;
    }}

    task <- 1;
}


(i32 x, i32 y, i32 a, i32 b)dot(i32? res)
{
    res <- x * a + y * b;
}

(i32 x, i32 y, i32 a, i32 b)crs(i32? res)
{
    res <- x * b - y * a;
}


()CreateMap(rect[]? resMap, i32? w, i32? h)
{
    rect[] map;
    map <- new rect[](7);

    map[0].x <- 300;
    map[0].y <- 500;
    map[0].a <- 350;
    map[0].b <- 550;

    map[1].x <- 100;
    map[1].y <- 200;
    map[1].a <- 150;
    map[1].b <- 250;

    map[2].x <- 200;
    map[2].y <- 200;
    map[2].a <- 250;
    map[2].b <- 250;

    map[3].x <- 400;
    map[3].y <- 500;
    map[3].a <- 450;
    map[3].b <- 650;

    map[4].x <- 300;
    map[4].y <- 100;
    map[4].a <- 550;
    map[4].b <- 150;

    map[5].x <- 0;
    map[5].y <- 300;
    map[5].a <- 200;
    map[5].b <- 350;

    map[6].x <- 500;
    map[6].y <- 500;
    map[6].a <- 600;
    map[6].b <- 650;

    resMap <- map;
    w <- 2000;
    h <- 1000;
}

(player p, rect[] map, i32 rect_size)SpawnPlayer(i32? task)
{
    i32 id;
    id <- (p?x + 3 * p?y) % `i32`?map; # random seed
    p?x <- (map[id].x + map[id].a) / 2;
    p?y <- map[id].y - rect_size;
    p?dx <- 0;
    p?dy <- 0;

    p?lives <- 100;
    p?power <- 500;
    
    p?pressAnyMove <- 0;
    p?jumps <- 2;
    p?pressUp <- 0;
    p?pressA <- 0;
    
    task <- 0;
}

[dllimport:Kernel32.dll]
[dllimport.entry:SleepEx]
(i32 time, i32 alertable)SleepEx(i32? error);

[dllimport:Kernel32.dll]
[dllimport.entry:GetLastError]
()GetLastError(i32? error);

[dllimport:Kernel32.dll]
[dllimport.entry:GetModuleHandleW]
(i16[] moduleName)GetModuleHandle(i64? hInstance);

[dllimport:Kernel32.dll]
[dllimport.entry:GetTickCount]
()GetTickCount(i32? miliseconds);

[dllimport:User32.dll]
[dllimport.entry:GetDC]
(i64 window)GetDC(i64? handle);

[dllimport:User32.dll]
[dllimport.entry:GetAsyncKeyState]
(i32 key)GetAsyncKeyState(i16? result);

[dllimport:User32.dll]
[dllimport.entry:PeekMessageW]
(
    i8[]  lpMsg,
    i64   hWnd,
    i32   wMsgFilterMin,
    i32   wMsgFilterMax,
    i32   wRemoveMsg
)PeekMessage(i32? handle);

[dllimport:User32.dll]
[dllimport.entry:TranslateMessage]
(i8[] lpMsg)TranslateMessage(i32? resultCode);

[dllimport:User32.dll]
[dllimport.entry:FillRect]
(i64 allocator, i32[] rect, i64 brush)FillRect(i32? resultCode);

[dllimport:User32.dll]
[dllimport.entry:DispatchMessageW]
(i8[] lpMsg)DispatchMessage(i32? resultCode);

[dllimport:Gdi32.dll]
[dllimport.entry:CreateCompatibleDC]
(i64 screen)CreateCompatibleDC(i64? handle);

[dllimport:Gdi32.dll]
[dllimport.entry:CreateSolidBrush]
(i32 color)CreateSolidBrush(i64? handle);

[dllimport:Gdi32.dll]
[dllimport.entry:GetStockObject]
(i32 stock)GetStockObject(i64? handle);

[dllimport:Gdi32.dll]
[dllimport.entry:SetBkMode]
(i64 allocator, i32 mode)SetBkMode(i32? prevMode);

[dllimport:Gdi32.dll]
[dllimport.entry:SetTextColor]
(i64 allocator, i32 color)SetTextColor(i32? prevColor);

[dllimport:Gdi32.dll]
[dllimport.entry:TextOutW]
(i64 allocator, i32 x, i32 y, i16[] text, i32 length)TextOut(i32? prevColor);

[dllimport:Gdi32.dll]
[dllimport.entry:BitBlt]
(i64 allocator, i32 x, i32 y, i32 cx, i32 cy, i64 src, i32 x1, i32 y1, i32 rop)BitBlt(i32? prevColor);

[dllimport:Gdi32.dll]
[dllimport.entry:Rectangle]
(i64 allocator, i32 left, i32 top, i32 right, i32 bottom)Rectangle(i64? handle);

[dllimport:Gdi32.dll]
[dllimport.entry:CreatePen]
(i32 style, i32 width, i32 color)CreatePen(i64? handle);

[dllimport:Gdi32.dll]
[dllimport.entry:CreateCompatibleBitmap]
(i64 allocator, i32 x, i32 y)CreateCompatibleBitmap(i64? handle);

[dllimport:Gdi32.dll]
[dllimport.entry:SelectObject]
(i64 allocator, i64 object)SelectObject(i64? oldObject);

[dllimport:Gdi32.dll]
[dllimport.entry:CreateFontW]
(
    i32    cHeight,
    i32    cWidth,
    i32    cEscapement,
    i32    cOrientation,
    i32    cWeight,
    i32    bItalic,
    i32    bUnderline,
    i32    bStrikeOut,
    i32    iCharSet,
    i32    iOutPrecision,
    i32    iClipPrecision,
    i32    iQuality,
    i32    iPitchAndFamily,
    i16[]  pszFaceName
)CreateFont(i64? handle);

[dllimport:User32.dll]
[dllimport.entry:GetClientRect]
(i64 window, i32[] rect)GetClientRect(i32? resultCode);


[dllimport:User32.dll]
[dllimport.entry:CreateWindowExW]
(
    i32     dwExStyle,
    i16[]   lpClassName,
    i16[]   lpWindowName,
    i32     dwStyle,
    i32     X,
    i32     Y,
    i32     nWidth,
    i32     nHeight,
    i64     hWndParent,
    i64     hMenu,
    i64     hInstance,
    i64     lpParam,
)CreateWindowEx(i64? hwnd);


[dllimport:User32.dll]
[dllimport.entry:MessageBoxW]
(i64 hwnd, i16[] text, i16[] caption, u32 type)MessageBox(i32? result);

[dllimport:Winmm.dll]
[dllimport.entry:mciSendStringW]
(i16[] text, i16[] res, i32 res_size, i64 callback_hwnd)mciSendString(i32? result);
