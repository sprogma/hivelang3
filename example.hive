#
#           state:
# x, y - position of player
# dx, dy - speed of player
#

struct rect
{
    i32 x, y, a, b;
}


class player
{
    i32 x, y;
    i32 dx, dy;
    i32 lives;
    i32 power;

    i8 pressUp; # to handle jumps
    i8 pressA;
    i8 pressB;
    i8 pressC;
}


[export:yes]
(i64[] args)main(i32? resultCode) 
{
    (0)GetModuleHandle(hInstance);

    i32 rect_size;
    rect_size <- 50;

    i64 hwnd;
    
    hwnd <- ?(
        0x200,
        new i16[]"#32770",
        new i16[]"Polling Only - Use Arrow Keys, ESC to exit",
        (0x00000000 | 0x00C00000 | 0x00080000 | 0x00040000 | 0x00020000 | 0x00010000) | 0x10000000,
        0x80000000, 
        0x80000000, 
        800, 
        600,
        0, 
        0, 
        ?hInstance, 
        0
    )CreateWindowEx(*);
    resultCode <- ?()GetLastError(*);

    match (hwnd)
    {
        `i64`0 {
            ?(0, new i16[]"Failed to create window", new i16[]"Error", 0x10)MessageBox(*);
        }
    }

    player me;
    me <- new player();

    me?x <- 100;
    me?y <- 100;
    me?dy <- 0;
    me?dy <- 0;

    i64 screen, allocator;
    screen <- ?(hwnd)GetDC(*);
    allocator <- ?(screen)CreateCompatibleDC(*);

    i32[] clientRect;
    clientRect <- new i32[](4);
    ?(hwnd, clientRect)GetClientRect(*);

    i32 width, height;
    width <- clientRect[2] - clientRect[0];
    height <- clientRect[3] - clientRect[1];

    i64 buffer, oldBuffer;
    buffer <- ?(screen, width, height)CreateCompatibleBitmap(*);
    oldBuffer <- ?(allocator, buffer)SelectObject(*);

    i64 font, oldFont;
    font <- ?(
        16,
        0,
        0,
        0,
        400,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        new i16[]"Arial"
    )CreateFont(*);

    oldFont <- ?(allocator, font)SelectObject(*);

    i64 backgroundBrush, rectBrush, rectPen;
    
    
    backgroundBrush <- ?(0xFFFFFF)CreateSolidBrush(*);
    rectBrush <- ?(0xFF8800)CreateSolidBrush(*);
    rectPen <- ?(0, 2, 0x000000)CreatePen(*);

    i8[] msg;
    i32 id;
    i32 running, lastTime, frameCount, fps;
    
    msg <- new i8[](48);
    running <- 1;
    lastTime <- ?()GetTickCount(*);
    frameCount <- fps <- 0;
    
    i32[] rect;
    rect <- new i32[](4);

    i16[] text;
    text <- new i16[]"Text!";

    rect[] map;
    rect[] particles;
    i32 particles_len;
    map <- ?()CreateMap(*);
    particles <- new rect[](512);
    particles_len <- 0;

    i32 isOnFoot;
    isOnFoot <- 0;

    ?(new i16[]"open \"C:\\Windows\\Media\\onestop.mid\" type sequencer alias music", 0, 0, 0)mciSendString(*);
    ?(new i16[]"play music", 0, 0, 0)mciSendString(*);
        
    while running = 1
    {
        while ?(msg, 0, 0, 0, 1)PeekMessage(*) <> 0
        {
            match (msg[8] = `i8`0x10 && msg[9] = `i8`0x00)
            {
                -1 {
                    running <- 0;
                }
            }
            match (msg[8] = `i8`0x02 && msg[9] = `i8`0x00)
            {
                -1 {
                    running <- 0;
                }
            }
            match (msg[8] = `i8`0x12 && msg[9] = `i8`0x00)
            {
                -1 {
                    running <- 0;
                }
            }
            ?(msg)TranslateMessage(*);
            ?(msg)DispatchMessage(*);
        }

        match ?(0x1B)GetAsyncKeyState(*) < `i16`0
        {
            -1 {
                running <- 0;
            }
        }

        match ?(0x25)GetAsyncKeyState(*) < `i16`0
        {
            -1 {
                me?x <- me?x - 15;
            }
        }

        match ?(0x27)GetAsyncKeyState(*) < `i16`0
        {
            -1 {
                me?x <- me?x + 15;
            }
        }

        match ?(0x26)GetAsyncKeyState(*) < `i16`0 && isOnFoot > 0
        {
            -1 {
                # me?y <- me?y - 15;
                me?dy <- -15;
                isOnFoot <- isOnFoot - 1;
            }
        }

        match ?(0x28)GetAsyncKeyState(*) < `i16`0
        {
            -1 {
                me?y <- me?y + 15;
            }
        }
        
        me?y <- me?y + me?dy;
        me?dy <- me?dy + 1;

        match me?x < 0 {-1{
            me?x <- 0;
        }}
        match me?x > width - rect_size {-1{
            me?x <- width - rect_size;
        }}
        match me?y < 0 {-1{
            me?y <- 0;
            me?dy <- 1;
        }}
        match me?y > height - rect_size {-1{
            me?y <- height - rect_size;
            me?dy <- 1;
            isOnFoot <- 2;
        }}
        
        ?(allocator, clientRect, backgroundBrush)FillRect(*);

        id <- 0;
        while id < `i32`?map
        {
            rect[0] <- map[id].x;
            rect[1] <- map[id].y;
            rect[2] <- map[id].a;
            rect[3] <- map[id].b;
            ?(allocator, rect, rectBrush)FillRect(*);
            id <- id + 1;

            match me?y + rect_size > map[id].y && me?x < map[id].a && me?x + rect_size > map[id].x && me?y < map[id].b {-1{
                me?y <- map[id].y - rect_size;
                me?dy <- 1;
                isOnFoot <- 2;
            }}
        }

        rect[0] <- me?x;
        rect[1] <- me?y;
        rect[2] <- me?x + rect_size;
        rect[3] <- me?y + rect_size;
        ?(allocator, rect, rectBrush)FillRect(*);

        i64 oldPen, oldBrush;
        oldPen <- ?(allocator, rectPen)SelectObject(*);
        oldBrush <- ?(allocator, ?(5)GetStockObject(*))SelectObject(*);
        
        ?(allocator, me?x, me?y, me?x + rect_size, me?y + rect_size)Rectangle(*);
        
        ?(allocator, oldBrush)SelectObject(*);
        ?(allocator, oldPen)SelectObject(*);



        ?(allocator, 1)SetBkMode(*);
        ?(allocator, 0x000000)SetTextColor(*);
        
        ?(allocator, 10, 10, text, ?text)TextOut(*);

        i32 currentTime;
        
        frameCount <- frameCount + 1;
        currentTime <- ?()GetTickCount(*);

        match currentTime - lastTime >= 1000
        {
            -1 {
                fps <- frameCount * 1000 / (currentTime - lastTime);
                frameCount <- 0;
                lastTime <- currentTime;
            }
        }


        ?(screen, 0, 0, width, height, allocator, 0, 0, 0xCC0020)BitBlt(*);
        
        ?(16, 1)SleepEx(*);
    }

    ?(new i16[]"stop music", 0, 0, 0)mciSendString(*);
    ?(new i16[]"close music", 0, 0, 0)mciSendString(*);
    
    # TODO: update this part
    # SelectObject(allocator, oldFont);
    # SelectObject(allocator, oldBuffer);
    # DeleteObject(font);
    # DeleteObject(buffer);
    # DeleteObject(backgroundBrush);
    # DeleteObject(rectBrush);
    # DeleteObject(rectPen);
    # DeleteDC(allocator);
    # ReleaseDC(hwnd, screen);
    
    # DestroyWindow(hwnd);

    resultCode <- 0;
}

[noinline:true]
()CreateMap(rect[]? resMap)
{
    rect[] map;
    map <- new rect[](5);
    
    map[0].x <- 0;
    map[0].y <- 0;
    map[0].a <- 50;
    map[0].b <- 50;
    
    map[1].x <- 100;
    map[1].y <- 200;
    map[1].a <- 150;
    map[1].b <- 250;
    
    map[2].x <- 200;
    map[2].y <- 200;
    map[2].a <- 250;
    map[2].b <- 250;
    
    map[3].x <- 400;
    map[3].y <- 500;
    map[3].a <- 450;
    map[3].b <- 650;
    
    map[4].x <- 300;
    map[4].y <- 100;
    map[4].a <- 550;
    map[4].b <- 150;

    resMap <- map;
}

[dllimport:Kernel32.dll]
[dllimport.entry:SleepEx]
(i32 time, i32 alertable)SleepEx(i32? error);

[dllimport:Kernel32.dll]
[dllimport.entry:GetLastError]
()GetLastError(i32? error);

[dllimport:Kernel32.dll]
[dllimport.entry:GetModuleHandleW]
(i16[] moduleName)GetModuleHandle(i64? hInstance);

[dllimport:Kernel32.dll]
[dllimport.entry:GetTickCount]
()GetTickCount(i32? miliseconds);

[dllimport:User32.dll]
[dllimport.entry:GetDC]
(i64 window)GetDC(i64? handle);

[dllimport:User32.dll]
[dllimport.entry:GetAsyncKeyState]
(i32 key)GetAsyncKeyState(i16? result);

[dllimport:User32.dll]
[dllimport.entry:PeekMessageW]
(
    i8[]  lpMsg,
    i64   hWnd,
    i32   wMsgFilterMin,
    i32   wMsgFilterMax,
    i32   wRemoveMsg
)PeekMessage(i32? handle);

[dllimport:User32.dll]
[dllimport.entry:TranslateMessage]
(i8[] lpMsg)TranslateMessage(i32? resultCode);

[dllimport:User32.dll]
[dllimport.entry:FillRect]
(i64 allocator, i32[] rect, i64 brush)FillRect(i32? resultCode);

[dllimport:User32.dll]
[dllimport.entry:DispatchMessageW]
(i8[] lpMsg)DispatchMessage(i32? resultCode);

[dllimport:Gdi32.dll]
[dllimport.entry:CreateCompatibleDC]
(i64 screen)CreateCompatibleDC(i64? handle);

[dllimport:Gdi32.dll]
[dllimport.entry:CreateSolidBrush]
(i32 color)CreateSolidBrush(i64? handle);

[dllimport:Gdi32.dll]
[dllimport.entry:GetStockObject]
(i32 stock)GetStockObject(i64? handle);

[dllimport:Gdi32.dll]
[dllimport.entry:SetBkMode]
(i64 allocator, i32 mode)SetBkMode(i32? prevMode);

[dllimport:Gdi32.dll]
[dllimport.entry:SetTextColor]
(i64 allocator, i32 color)SetTextColor(i32? prevColor);

[dllimport:Gdi32.dll]
[dllimport.entry:TextOutW]
(i64 allocator, i32 x, i32 y, i16[] text, i32 length)TextOut(i32? prevColor);

[dllimport:Gdi32.dll]
[dllimport.entry:BitBlt]
(i64 allocator, i32 x, i32 y, i32 cx, i32 cy, i64 src, i32 x1, i32 y1, i32 rop)BitBlt(i32? prevColor);

[dllimport:Gdi32.dll]
[dllimport.entry:Rectangle]
(i64 allocator, i32 left, i32 top, i32 right, i32 bottom)Rectangle(i64? handle);

[dllimport:Gdi32.dll]
[dllimport.entry:CreatePen]
(i32 style, i32 width, i32 color)CreatePen(i64? handle);

[dllimport:Gdi32.dll]
[dllimport.entry:CreateCompatibleBitmap]
(i64 allocator, i32 x, i32 y)CreateCompatibleBitmap(i64? handle);

[dllimport:Gdi32.dll]
[dllimport.entry:SelectObject]
(i64 allocator, i64 object)SelectObject(i64? oldObject);

[dllimport:Gdi32.dll]
[dllimport.entry:CreateFontW]
(
    i32    cHeight,
    i32    cWidth,
    i32    cEscapement,
    i32    cOrientation,
    i32    cWeight,
    i32    bItalic,
    i32    bUnderline,
    i32    bStrikeOut,
    i32    iCharSet,
    i32    iOutPrecision,
    i32    iClipPrecision,
    i32    iQuality,
    i32    iPitchAndFamily,
    i16[]  pszFaceName
)CreateFont(i64? handle);

[dllimport:User32.dll]
[dllimport.entry:GetClientRect]
(i64 window, i32[] rect)GetClientRect(i32? resultCode);


[dllimport:User32.dll]
[dllimport.entry:CreateWindowExW]
(
    i32     dwExStyle,
    i16[]   lpClassName,
    i16[]   lpWindowName,
    i32     dwStyle,
    i32     X,
    i32     Y,
    i32     nWidth,
    i32     nHeight,
    i64     hWndParent,
    i64     hMenu,
    i64     hInstance,
    i64     lpParam,
)CreateWindowEx(i64? hwnd);


[dllimport:User32.dll]
[dllimport.entry:MessageBoxW]
(i64 hwnd, i16[] text, i16[] caption, u32 type)MessageBox(i32? result);

[dllimport:Winmm.dll]
[dllimport.entry:mciSendStringW]
(i16[] text, i16[] res, i32 res_size, i64 callback_hwnd)mciSendString(i32? result);
